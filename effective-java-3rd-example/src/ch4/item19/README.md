# 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.
널리 쓰일 클래스를 상속용으로 설계한다면 다음 사항들을 주의하자.
1. 내부 사용 패턴 문서화
2. protected 메서드와 필드 신중히 선택
3. 생성자에 재정의 가능 메서드 호출 x
4. Cloneable, Serializable 인터페이스를 구현할 때 주의

상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하기 때문에 상속용으로 설계한 클래슨는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.
- 꼭 필요한 protected 메서드를 놓쳤다면 하위 클래스를 작성할 때 빈자리가 드러난다.
- 거꾸로, 하위 클래스를 여러 개 만들 때 까지 전혀 쓰이지 않는 protected 멤버는 사실 private이었어야 할 가능성이 크다.
- 저자의 경험상 이러한 검증은 하위 클래스 3개 정도가 적당하다고 한다.

<br>

## 상속용으로 설계하지 않은 클래스는 절대 상속해서는 안된다.
전통적으로 일반적인 구체 클래스는 final도 아니고 상속용으로 설계되거나 문서화되지도 않았다. 하지만 그대로 두면 위험하다. 변화가 생길 때마다 하위 클래스를 오동작하게 만들 수 있기 때문이다. 실제로 보통 구체 클래스 내부만 수정했음에도 이를 확장한 클래스에서 문제가 생겼다는 버그 리포트가 드물지 않게 발생한다.

따라서 상속용으로 설계하지 않은 클래스는 상속을 금지해야 한다. 상속을 금지하는 방법은 두 가지다.
1. 클래스를 final로 선언하기
2. 모든 생성자를 private이나 package-private으로 선언하고 public 정적 팩토리 만들기

구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해진다. 이런 클래스라도 상속을 꼭 허용해야겠다면 합당한 방법이 하나 있다. 
- 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기는 것이다.
- 클래스의 동작을 유지하면서 재정의 가능 메서드를 사용하는 코드를 제거할 수 있는 기계적인 방법은
    - 먼저 각각의 재정의 가능 메서드의 본문 코드를 private ‘도우미 메서드’로 옮기고, 이 도우미 메서드를 호출하도록 수정한다.
    - 그런 다음 재정의 가능 메서드를 호출하는 다른 코드들도 모두 이 도우미 메서드를 직접 호출하도록 수정한다.

<br>

## 핵심 정리
상속용 클래스를 설계하기란 결코 만만치 않다. 
1. 클래스 내부에서 스스로를 어떻게 사용하는지(자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다. 그러지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있다.
2. 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다. 

그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것이다. 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들며 된다.

--- 

💡 본문은 [개발 블로그](https://loosie.tistory.com/650) 에 있습니다.